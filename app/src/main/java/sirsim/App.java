/*
 * This source file was generated by the Gradle 'init' task
 */
package sirsim;

import sirsim.percolation.KCorePercolation;
import sirsim.utils.Logger;

import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        if (args.length > 0 && args[0].equalsIgnoreCase("kcore")) {
            runKCoreCLI(slice(args, 1));
        } else {
            System.out.println(new App().getGreeting());
        }
    }

    private static void runKCoreCLI(String[] args) {
        Logger log = new Logger(App.class);
        Map<String, String> opt = parseArgs(args);

        int n = parseInt(opt, "--n", 10000);
        int k = parseInt(opt, "--k", 3);
        double z = parseDouble(opt, "--z", 6.0);
        double pmin = parseDouble(opt, "--pmin", 0.0);
        double pmax = parseDouble(opt, "--pmax", 1.0);
        int steps = parseInt(opt, "--steps", 41);
        int trials = parseInt(opt, "--trials", 10);
        long seed = parseLong(opt, "--seed", System.currentTimeMillis());
        String out = opt.getOrDefault("--out", String.format("out/kcore/%d/results.csv", n));

        log.info("Run k-core percolation: N=%d, k=%d, z=%.3f, p in [%.3f, %.3f] steps=%d, trials=%d", n, k, z, pmin, pmax, steps, trials);
        try {
            KCorePercolation.sweepER_Z(n, z, k, pmin, pmax, steps, trials, seed, Path.of(out));
            log.info("Saved: %s", out);
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static Map<String, String> parseArgs(String[] args) {
        Map<String, String> m = new HashMap<>();
        for (int i = 0; i < args.length; i++) {
            String a = args[i];
            if (a.startsWith("--")) {
                String v = "true";
                if (i + 1 < args.length && !args[i + 1].startsWith("--")) {
                    v = args[++i];
                }
                m.put(a, v);
            }
        }
        return m;
    }

    private static int parseInt(Map<String, String> m, String k, int def) {
        try { return Integer.parseInt(m.getOrDefault(k, String.valueOf(def))); }
        catch (Exception e) { return def; }
    }
    private static long parseLong(Map<String, String> m, String k, long def) {
        try { return Long.parseLong(m.getOrDefault(k, String.valueOf(def))); }
        catch (Exception e) { return def; }
    }
    private static double parseDouble(Map<String, String> m, String k, double def) {
        try { return Double.parseDouble(m.getOrDefault(k, String.valueOf(def))); }
        catch (Exception e) { return def; }
    }
    private static String[] slice(String[] a, int from) {
        int n = Math.max(0, a.length - from);
        String[] b = new String[n];
        System.arraycopy(a, from, b, 0, n);
        return b;
    }
}
